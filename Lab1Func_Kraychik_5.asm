; в качестве неприводимого многочлена выбран f = x^64 + x^4 + x^3 + x + 1
; т.о. GF2_64 = Z/2Z[x] / f
; вычитание совпадает со сложением
; все многочлены над полем GF2_64 хранятся в памяти от старших коэффицентов к младшим,
; то есть коэффицент при старшей степени многочлена хранится в нулевой ячейке массива

.CODE

GF_MulX PROC							; rcx - a (элемент поля)
	cmp rcx, 0							; сравнение элемента а и 0
	mov rdx, 27							; 27 = x^4 + x^3 + x + 1
	mov r8, 0							; подготовка к команде cmovg
	cmovg rdx, r8						; rdx = (rcx < 0) ? 27 : 0
	sal rcx, 1							; умножение на x
	xor rcx, rdx						; факторизация
	mov rax, rcx						; возвращаемое значение
	ret
GF_MulX ENDP

GF_PowX PROC							; ecx - Power (unsigned int)
	; сохранение значений регистров на стек
	push rbx
	push rbp
	mov rbp, 1							; присвоение начального значения
										; далее следует цикл с Power итераций
	m2:
		cmp rcx, 0						; сравнение rcx и 0
		je m1							; если rcx == 0, переход к метке m1
		mov rbx, rcx					; копирование rcx на rbx
		mov rcx, rbp					; запись на rcx rbp, чтобы передать в функцию rbp
										; в качестве параметра функции
		call GF_MulX
		mov rbp, rax					; запись результата работы функции на rbp
		mov rcx, rbx					; восстановление счетчика на rcx
		dec rcx							; уменьшение счетчика
		jmp m2							; переход к метке m2
	m1:
	mov rax, rbp						; на rax находится возвращаемое значение
	; восстановление значений
	pop rbp
	pop rbx
	ret
GF_PowX ENDP

; вспомогательная процедура
get_bit PROC							; rcx - элемент GF2_64
										; rdx - номер бита
	mov r8, rcx							; копирование rcx на r8
	mov cl, dl			
	ror r8, cl							; теперь искомый бит находится в нулевом бите
	mov r9, r8							; копирование r8 на r9
	; выделение нулевого бита
	sar r8, 1
	sal r8, 1
	xor r8, r9							; в r8 хранится результат
	mov rax, r8
	ret
get_bit ENDP

GF_Multiply PROC						; rcx - a (первый элемент)
										; rdx - b (второй элемент)
	; сохранение значений в стеке для последующего восстановления
	push r15
	push r14
	push r13
	push r12
	push rsi
	; умножение нулевого бита элемента b на a 
	mov r15, rcx						; копирование rcx на r15
	mov r14, rdx						; копирование rdx на r14
	mov rcx, rdx						; подготовка к вызову	
	mov rdx, 0							; функции get_bit
	call get_bit
	imul r15							; результат будет содержаться только в rax, rdx обнулится
	mov r13, rax						; r13 содержит текущее произведение
	mov r12, r15						; r12 будет сожержать a*(x^i), где i = 0..63
										; в данный момент i == 0
	xor rsi, rsi						; rsi - количество итераций цикла, обнуление
	; цикл по всем битам b
	m1:
		cmp rsi, 63						; сравнение rsi и 63
		je m2							; если rsi == 63, переход к метке m2
		inc rsi							; rsi++
		mov rcx, r12					; подготовка к вызову GF_MulX
		call GF_MulX
		mov r12, rax					; обновление значения r12 = a*(x^rsi)
		mov rcx, r14					; подготовка к вызову get_bit
		mov rdx, rsi					; rcx = b, rsi - номер бита
		call get_bit
		imul r12						; вычисление произведения результата get_bit и r12
		xor r13, rax					; добавление к регистру, содержащему результат
		jmp m1
	m2:
	mov rax, r13						; возвращаемое значение
	; восстановление значений
	pop rsi
	pop r12
	pop r13
	pop r14
	pop r15
	ret
GF_Multiply ENDP

GF_Reciprocal PROC						; rcx - a (элемент поля)
	; сохранения значений регистров для последующего восстановления
	push rbx
	push rbp
	push r12
	push rsi
	; подготовка к вызову GF_Multiply
	mov rbx, rcx						; копирование a (первый аргумент уже на rcx)
	mov rdx, rbx						; копирование a (второй аргумент)
	call GF_Multiply					; вызов GF_Multiply
	mov rbp, rax						; rbp - переменная, которая будет возводится в квадрат
	mov r12, rbp						; r12 - в нем хранится результат
	mov rcx, 62							; счетчик цикла
	m1:
		mov rsi, rcx					; сохранение счетчика цикла
		; подготовка к вызову GF_Multiply (возведение в квадрат)
		mov rcx, rbp					; первый аргумент
		mov rdx, rbp					; второй аргумент
		call GF_Multiply
		mov rbp, rax					; сохранение результата возведения в квадрат
		; подготовка к вызову GF_Multiply (текущее произведение)
		mov rcx, rbp					; первый аргумент
		mov rdx, r12					; второй аргумент
		call GF_Multiply
		mov r12, rax					; сохранение результата
		mov rcx, rsi					; восстановление счетчика цикла
		loop m1							; уменьшение rcx, условный переход к m1
	mov rax, r12						; возвращаемое значение
	; восстановление значений регистров из стека
	pop rsi
	pop r12
	pop rbp
	pop rbx
	ret
GF_Reciprocal ENDP

PolyMulX PROC							; rcx - указатель на многочлен a
										; edx - степень многочлена deg, тип данных int
	mov rax, -1							; если deg == -1, вернем значение -1
	cmp edx, -1							; тип int является 32-битным
	je m1								; если deg == 1, конец функции
	inc rdx								; степень результата на 1 больше степени многочлена
	mov r8, rdx							; подготовка к умножению
	mov rax, 8							; каждая переменная GF2_64 занимает 8 байт
	imul rdx							; в rax находится величина сдвига в массиве
	mov r9, 0							; при умножении на x, коэффицент
										; при младшей степени становится нулем
	mov [rcx+rax], r9					; a[deg+1] = 0
	mov rax, r8							; возвращается степень нового многочлена
	m1:
	ret
PolyMulX ENDP

PolyMulConst PROC						; rcx - указатель на массив a
										; rdx - степень многочлена deg, имеет тип int
										; r8 - элемент поля GF2_64
	; если константа равна 0, вернем степень -1
	mov rax, -1			
	cmp r8, 0							; сравнение константы с нулем
	je m3								; если константа равна 0, прекращаем работу функции
	cmp edx, -1							; сравнение степени с -1 (int 32-битный)
	je m3								; если они равны, завершить процедуру, вернув -1
	; сохранение значений в стеке
	push r15
	push r14
	push r13
	push rsi
	; сохранение значений rcx, rdx, r8
	mov r15, rcx
	mov r14, rdx
	mov r13, r8
	xor rsi, rsi						; обнуление счетчика для цикла
	m2:
		cmp rsi, r14					; сравнение счетчика и deg
		jg m1							; если rsi > deg прерываем цикл
		mov rcx, [r15+8*rsi]			; вычисление адреса текущего коэффицента многочлена
										; и запись его на регистр rcx
		mov rdx, r13					; запись константы на rdx
		call GF_Multiply				; нахождение произведения rcx и rdx
		mov [r15+8*rsi], rax			; запись произведения в массив
		inc rsi							; увеличение счетчика на единицу
		jmp m2
	m1:
	; восстановление значений из стека
	mov rax, r14						; возвращаемым значением является степень многочлена
	pop rsi
	pop r13
	pop r14
	pop r15
	m3:
	ret
PolyMulConst ENDP

PolyZero PROC							; rcx - указатель на массив a
										; edx - степень многочлена deg, является типом int
	xor r8, r8							; обнуление r8, всегда является нулем
	m1:
		cmp edx, 0						; сравнение степени с 0
		jl m2							; если степень меньше нуля, перейти к метке m2
		mov [rcx+8*rdx], r8				; обнуление коэффицента многочлена
		dec edx							; уменьшение edx на единицу
		jmp m1							; вернкться к началу цикла
	m2:
	mov eax, -1							; возвращаемым значением является
										; 32-битная -1
										; возвращаемое значение типа int
	ret
PolyZero ENDP

PolyCpy PROC							; rcx - указатель на приемник (dest)
										; rdx - указатель на источник (src)
										; r8 - степень многочлена deg, имеет тип unsigned char
	
	; сохранение регистров в памяти
	push rsi
	push rdi

	mov r9, rcx							; копирование rcx на r9
	mov rax, r8							; возвращаемое значение
	mov rsi, rdx						; адрес источника
	mov rdi, r9							; адрес приемника
	mov rcx, r8							; счетчик
	inc rcx								; степень на 1 меньше кол-ва коэффицентов
	cld									; значение будет увеличиваться
	rep movsq							; копирование массива, на rcx счетчик
	; восстановление значений регистров
	pop rdi
	pop rsi
	ret
PolyCpy ENDP

PolySum PROC							; rcx - адрес результата (sum)
										; rdx - адрес первого многочлена (a)
										; r8 - степень первого многолчена (deg_a)
										; r9 - адрес второго многочлена (b)
										; [rsp+40] - степень второго многочлена (deg_b)
	
	mov eax, [rsp+40]					; теперь на eax лежит deg_b
	; сохранение значений регистров
	push r12
	push r13
	push r14
	cdqe								; знаковое расширение eax до rax
	; расширение r8d до r8
	xchg rax, r8
	cdqe
	xchg rax, r8
	; теперь все используемые регистры 64-битные
	mov r10, r8							; инициализация первого индекса i
	mov r12, rax						; инициализация второго индекса j
	; запись на r13 максимума из deg_a, deg_b
	mov r13, r8							; r13 - индекс в массиве sum, обозначим k
	cmp r8, rax							; сравнение deg_a и deg_b
	cmovl r13, rax						; если r8 < rax => r13 = rax
	mov r14, r13						; копирование r13 в r14
	; далее следуют циклы
	m1:
		cmp r10, 0						; сравнение r10 и 0
		jl m2							; если r10 < 0, переход к метке m2
		cmp r12, 0						; сравнение r12 и 0
		jl m2							; если r12 < 0, переход к метке m2
		mov r11, [rdx+8*r10]			; r11 = a[i]
		xor r11, [r9+8*r12]				; r11 += b[j]
		mov [rcx+8*r13], r11			; sum[k] = a[i] + b[j]
		dec r10							; i--
		dec r12							; j--
		dec r13							; k--
		jmp m1
	m2:
		cmp r10, 0						; сравнение i и 0
		jl m3							; если i < 0, переход к m3
		mov r11, [rdx+8*r10]			; r11 = a[i]
		mov [rcx+8*r13], r11			; sum[k] = a[i]
		dec r10							; i--
		dec r13							; k--
		jmp m2
	m3:
		cmp r12, 0						; сравнение j и 0
		jl m4							; если j < 0, переход к m4
		mov r11, [r9+8*r12]				; r11 = b[j]
		mov [rcx+8*r13], r11			; sum[k] = b[j]
		dec r12							; j--
		dec r13							; k--
		jmp m3
	m4:
	mov rax, r14						; возвращаемым значением является max(deg_a, deg_b)
	; восстановление значений регистров
	pop r14
	pop r13
	pop r12
	ret
PolySum ENDP

END